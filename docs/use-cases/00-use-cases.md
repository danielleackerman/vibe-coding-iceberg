---
title: Use Cases
nav_order: ""
description: An overview of various use cases that demonstrate how the Vibe Coding Iceberg framework can be applied in different project types.
tags:
  - use cases
  - examples
  - vibe coding
layout: default
---
# ðŸš€ Use Cases & Project Blueprints

This section serves as a practical playbook. We've covered the individual concepts and toolsâ€”the "what." Now, we'll explore the "how"â€”the way these pieces are assembled in different combinations to create real-world projects.

Each of the following blueprints represents a common type of application. They showcase how a specific goal dictates your architectural choices, from the frontend and data layers all the way to deployment. This is the "bird's-eye view" in action, designed to provide a mental model for how to approach your own projects.

---
### Blueprint 1: The Modern Marketing Site & Blog

* #### The Goal:
    To build a lightning-fast, visually polished website with excellent Search Engine Optimization (SEO). The primary purpose is to showcase a brand, provide information, and publish content like blog posts or case studies. Performance and SEO are paramount.

* #### Architectural Choices & Connections:
    * **Fullstack Builder:** **Astro** or **Next.js** are the top choices.
        * **Why?** Both excel at Static Site Generation (SSG). This means they pre-build the entire website into simple HTML, CSS, and JavaScript files during the deployment process. Serving static files is the absolute fastest way to deliver a website, which is a major factor for both user experience and Google search rankings.
    * **Data Layer:** A **Headless CMS** (Content-as-a-Service) like **Contentful**, **Sanity.io**, or **Payload CMS**.
        * **The Connection:** This decouples content management from your code. Your marketing team can write and update blog posts in a user-friendly web interface (the CMS), and your Astro/Next.js site fetches this content via an **API** only when it builds. This is a secure and efficient way to manage content.
    * **Infrastructure:** A **Frontend Cloud** platform like **Vercel**, **Netlify**, or **Cloudflare Pages**.
        * **The Connection:** These platforms are optimized for hosting the static files generated by builders like Astro and Next.js. They automatically distribute your site across a global Content Delivery Network (CDN), ensuring that it loads almost instantly for users anywhere in the world.

* #### Example AI Prompt for this Workflow:
    > "Using **Astro**, create a new blog page that fetches all posts at build time from the **Sanity.io** GraphQL API. For each post, generate a separate, static HTML page using Astro's dynamic routing. The page must include correct SEO meta tags for the post's title and description."

---
### Blueprint 2: The SaaS Application / Interactive Dashboard

* #### The Goal:
    To build a secure, data-intensive web application that users must log into. Inside, they can interact with complex data, visualize information, and perform actions specific to their account.

* #### Architectural Choices & Connections:
    * **Fullstack Builder:** **Next.js** or **Remix**.
        * **Why?** Their integrated frontend and backend model is perfect for this use case. They allow you to build a highly interactive user interface while also providing a secure, server-side environment to write the complex API logic needed to interact with a database.
    * **Authentication:** A dedicated **Authentication Platform** like **Clerk** or **Auth0**.
        * **The Connection:** Building secure authentication is extremely difficult. These services handle the entire user identity lifecycleâ€”from sign-up forms and social logins to password resets and session management. You integrate their components into your **Next.js** frontend and use their SDKs on your backend to protect your **API routes**.
    * **Data Layer:** A robust **Relational Database (SQL)**, accessed through a modern service.
        * **Examples:** **Supabase** (a BaaS that provides a PostgreSQL database) or a **Serverless Database** like **Neon** or **PlanetScale**.
        * **The Connection:** A SaaS application lives and dies by its data integrity. A powerful SQL database is essential. Your **Next.js API routes** will use an **ORM** like **Prisma** to communicate with the database, performing the complex queries needed for the dashboard.
    * **Infrastructure:** Typically **Vercel** for the Next.js application, which then connects to your chosen database and auth services running elsewhere.

* #### Example AI Prompt for this Workflow:
    > "Create a protected **Next.js API route** that uses **Prisma** to fetch all 'invoices' belonging to the currently authenticated user. Use the `getAuth` function from **Clerk** to retrieve the `userId` on the server and use it to filter the database query."

---
### Blueprint 3: The AI-Powered Application

* #### The Goal:
    To build a tool that leverages a Large Language Model (LLM) to provide a unique service, such as a chatbot that can answer questions about a private knowledge base (a technique known as Retrieval-Augmented Generation, or RAG).

* #### Architectural Choices & Connections:
    * **Fullstack Builder:** **Next.js** remains a top choice due to its excellent backend capabilities and ecosystem.
    * **Data Layer:** This is the key difference. In addition to a primary database, you need a **Vector Database** like **Pinecone**, **Weaviate**, or **Chroma**.
        * **The Connection:** You convert your knowledge base (e.g., PDFs, documents) into numerical representations called "embeddings" and store them here. When a user asks a question, your backend first queries the vector database to find the most semantically relevant chunks of text.
    * **Backend Logic & External APIs:** Your backend's primary job is to orchestrate calls between multiple services. The workflow is: User query comes in -> Query vector database -> Get relevant context -> Send the original query *plus* the context to an **External API** from a provider like **OpenAI (GPT-4o)** or **Anthropic (Claude 3)**.
    * **Frontend:** The UI is often a chat interface, which can be easily built using libraries like the **Vercel AI SDK**.

* #### Example AI Prompt for this Workflow:
    > "Using the **Vercel AI SDK** and **LangChain.js**, create a **Next.js API route** that takes a user's query. The route must first use the `Pinecone` client to fetch the top 3 most relevant documents from our vector store, then pass those documents as context along with the user's query to the **OpenAI GPT-4o** model to generate a final answer. Stream the response back to the client."

---
### Summary Decision Matrix: Project Blueprints

| Project Type | Primary Goal | Recommended Fullstack Builder | Typical Data Layer | Key Technology |
| :--- | :--- | :--- | :--- | :--- |
| **Marketing Site / Blog** | Performance & SEO | **Astro**, Next.js (SSG) | Headless CMS (Contentful, Sanity) | Static Site Generation |
| **SaaS App / Dashboard** | Data Interaction & Security | **Next.js**, Remix | Relational Database (PostgreSQL via Supabase/Neon) | Authentication Platform (Clerk) |
| **AI Application** | Intelligent Interaction | **Next.js** | Vector Database (Pinecone, Chroma) + Primary DB | External LLM API (OpenAI) |
| **Simple Internal Tool** | Speed of Development | (Consider Low-Code) | Integrated Database | Visual Builder / No-Code Logic |